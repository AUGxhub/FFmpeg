/*
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#include "libavutil/float_dsp.h"
#include "libavutil/intreadwrite.h"
#include "libavutil/tx.h"

#include "avcodec.h"
#define BITSTREAM_READER_LE
#include "get_bits.h"
#include "internal.h"

#define FRAME_LENGTH 960
#define FREQ_LENGTH 800
#define MAX_SEGMENT_LENGTH 480
#define NUM_TIME_SWITCHING_BLOCKS 4

#define NUM_MAP_BANDS 20

#define STOP_BAND      800
#define STOP_BAND4     200

#define SFM_G1         16
#define SFM_G2         8
#define SFM_G1G2       24
#define SFM_G3         12
#define SFM_N          36
#define SFM_GX         8
#define NB_SFM         44
#define WID_G1         8
#define WID_G2         16
#define WID_G3         24
#define WID_GX         32
#define NUMC_G1        128
#define NUMC_G1G2      256
#define NUMC_N         544
#define NB_VECT1       1
#define NB_VECT2       2
#define NB_VECT3       3
#define NB_VECTX       4

#define NUMC_G23       256
#define NUMC_G1SUB     32
#define NUMC_G1G2SUB   64
#define NUMC_G1G2G3SUB 136

#define QBIT_MAX1      5
#define QBIT_MAX2      9
#define OFFSETf        0.015625f
#define FCT_LVQ1f      1.1f
#define FCT_LVQ2f      6.0f
#define FCT_LVQ2fQ13   1365.333333f
#define MAX_DIST       100000000.0f
#define N_LEADER1      10

#define FLAGS_BITS     3
#define NORM0_BITS     5
#define NORMI_BITS     5
#define NUMNRMIBITS    215

#define NOALLGROUPS    0
#define ALLGROUPS      1

#define NOHUFCODE      0
#define HUFCODE        1
#define MIN16B    (int16_t)0x8000
#define MAX16B    (int16_t)0x7fff

#define MLT960_LENGTH         960
#define MLT960_LENGTH_DIV_2   480
#define MLT960_LENGTH_MINUS_1 959
#define MLT240_LENGTH         240
#define MLT240_LENGTH_MINUS_1 239

static const float window[960] = {
    0.000823975f, 0.00244141f, 0.00408936f, 0.0057373f, 0.00735474f, 0.00900269f,
    0.0106506f, 0.0122681f, 0.013916f, 0.0155334f, 0.0171814f, 0.0188293f,
    0.0204468f, 0.0220947f, 0.0237122f, 0.0253601f, 0.0270081f, 0.0286255f,
    0.0302734f, 0.0318909f, 0.0335388f, 0.0351868f, 0.0368042f, 0.0384521f,
    0.0400696f, 0.0417175f, 0.043335f, 0.0449829f, 0.0466309f, 0.0482483f,
    0.0498962f, 0.0515137f, 0.0531616f, 0.0547791f, 0.056427f, 0.0580444f,
    0.0596924f, 0.0613098f, 0.0629578f, 0.0645752f, 0.0662231f, 0.0678406f,
    0.0694885f, 0.071106f, 0.0727539f, 0.0743713f, 0.0760193f, 0.0776367f,
    0.0792847f, 0.0809021f, 0.08255f, 0.0841675f, 0.0857849f, 0.0874329f,
    0.0890503f, 0.0906982f, 0.0923157f, 0.0939331f, 0.0955811f, 0.0971985f,
    0.0988464f, 0.100464f, 0.102081f, 0.103729f, 0.105347f, 0.106964f,
    0.108582f, 0.110229f, 0.111847f, 0.113464f, 0.115112f, 0.11673f,
    0.118347f, 0.119965f, 0.121613f, 0.12323f, 0.124847f, 0.126465f,
    0.128082f, 0.12973f, 0.131348f, 0.132965f, 0.134583f, 0.1362f,
    0.137817f, 0.139435f, 0.141052f, 0.14267f, 0.144287f, 0.145935f,
    0.147552f, 0.14917f, 0.150787f, 0.152405f, 0.154022f, 0.15564f,
    0.157257f, 0.158844f, 0.160461f, 0.162079f, 0.163696f, 0.165314f,
    0.166931f, 0.168549f, 0.170166f, 0.171753f, 0.17337f, 0.174988f,
    0.176605f, 0.178223f, 0.17981f, 0.181427f, 0.183044f, 0.184662f,
    0.186249f, 0.187866f, 0.189484f, 0.191071f, 0.192688f, 0.194275f,
    0.195892f, 0.19751f, 0.199097f, 0.200714f, 0.202301f, 0.203918f,
    0.205505f, 0.207123f, 0.20871f, 0.210297f, 0.211914f, 0.213501f,
    0.215118f, 0.216705f, 0.218292f, 0.21991f, 0.221497f, 0.223083f,
    0.22467f, 0.226288f, 0.227875f, 0.229462f, 0.231049f, 0.232635f,
    0.234253f, 0.23584f, 0.237427f, 0.239014f, 0.240601f, 0.242188f,
    0.243774f, 0.245361f, 0.246948f, 0.248535f, 0.250122f, 0.251709f,
    0.253296f, 0.254852f, 0.256439f, 0.258026f, 0.259613f, 0.2612f,
    0.262756f, 0.264343f, 0.26593f, 0.267487f, 0.269073f, 0.27066f,
    0.272217f, 0.273804f, 0.27536f, 0.276947f, 0.278534f, 0.28009f,
    0.281647f, 0.283234f, 0.28479f, 0.286377f, 0.287933f, 0.28949f,
    0.291077f, 0.292633f, 0.294189f, 0.295746f, 0.297333f, 0.298889f,
    0.300446f, 0.302002f, 0.303558f, 0.305115f, 0.306671f, 0.308228f,
    0.309784f, 0.31134f, 0.312897f, 0.314453f, 0.31601f, 0.317566f,
    0.319122f, 0.320679f, 0.322205f, 0.323761f, 0.325317f, 0.326843f,
    0.3284f,  0.329956f, 0.331482f, 0.333038f, 0.334564f, 0.336121f,
    0.337646f, 0.339203f, 0.340729f, 0.342285f, 0.343811f, 0.345337f,
    0.346893f, 0.348419f, 0.349945f, 0.351471f, 0.353027f, 0.354553f,
    0.356079f, 0.357605f, 0.359131f, 0.360657f, 0.362183f, 0.363708f,
    0.365234f, 0.36676f, 0.368286f, 0.369812f, 0.371307f, 0.372833f,
    0.374359f, 0.375885f, 0.37738f, 0.378906f, 0.380402f, 0.381927f,
    0.383453f, 0.384949f, 0.386475f, 0.38797f, 0.389465f, 0.390991f,
    0.392487f, 0.393982f, 0.395508f, 0.397003f, 0.398499f, 0.399994f,
    0.401489f, 0.402985f, 0.40448f, 0.405975f, 0.407471f, 0.408966f,
    0.410461f, 0.411957f, 0.413452f, 0.414948f, 0.416443f, 0.417908f,
    0.419403f, 0.420898f, 0.422363f, 0.423859f, 0.425323f, 0.426819f,
    0.428284f, 0.429779f, 0.431244f, 0.432739f, 0.434204f, 0.435669f,
    0.437134f, 0.438629f, 0.440094f, 0.441559f, 0.443024f, 0.444489f,
    0.445953f, 0.447418f, 0.448883f, 0.450348f, 0.451813f, 0.453247f,
    0.454712f, 0.456177f, 0.457642f, 0.459076f, 0.460541f, 0.462006f,
    0.46344f, 0.464905f, 0.466339f, 0.467773f, 0.469238f, 0.470673f,
    0.472107f, 0.473572f, 0.475006f, 0.47644f, 0.477875f, 0.479309f,
    0.480743f, 0.482178f, 0.483612f, 0.485046f, 0.486481f, 0.487915f,
    0.489349f, 0.490753f, 0.492188f, 0.493622f, 0.495026f, 0.49646f,
    0.497864f, 0.499298f, 0.500702f, 0.502136f, 0.50354f, 0.504944f,
    0.506378f, 0.507782f, 0.509186f, 0.51059f, 0.511993f, 0.513397f,
    0.514801f, 0.516205f, 0.517609f, 0.519012f, 0.520416f, 0.52179f,
    0.523193f, 0.524597f, 0.52597f, 0.527374f, 0.528748f, 0.530151f,
    0.531525f, 0.532928f, 0.534302f, 0.535675f, 0.537079f, 0.538452f,
    0.539825f, 0.541199f, 0.542572f, 0.543945f, 0.545319f, 0.546692f,
    0.548065f, 0.549438f, 0.550812f, 0.552155f, 0.553528f, 0.554901f,
    0.556244f, 0.557617f, 0.55896f, 0.560333f, 0.561676f, 0.563019f,
    0.564392f, 0.565735f, 0.567078f, 0.56842f, 0.569763f, 0.571106f,
    0.572449f, 0.573792f, 0.575134f, 0.576477f, 0.57782f, 0.579163f,
    0.580475f, 0.581818f, 0.58313f, 0.584473f, 0.585785f, 0.587128f,
    0.58844f, 0.589783f, 0.591095f, 0.592407f, 0.593719f, 0.595032f,
    0.596344f, 0.597656f, 0.598969f, 0.600281f, 0.601593f, 0.602905f,
    0.604218f, 0.605499f, 0.606812f, 0.608124f, 0.609406f, 0.610718f,
    0.612f,    0.613281f, 0.614594f, 0.615875f, 0.617157f, 0.618439f,
    0.619751f, 0.621033f, 0.622314f, 0.623596f, 0.624847f, 0.626129f,
    0.627411f, 0.628693f, 0.629944f, 0.631226f, 0.632507f, 0.633759f,
    0.63504f, 0.636292f, 0.637543f, 0.638824f, 0.640076f, 0.641327f,
    0.642578f, 0.643829f, 0.645081f, 0.646332f, 0.647583f, 0.648834f,
    0.650055f, 0.651306f, 0.652557f, 0.653778f, 0.655029f, 0.65625f,
    0.657501f, 0.658722f, 0.659973f, 0.661194f, 0.662415f, 0.663635f,
    0.664856f, 0.666077f, 0.667297f, 0.668518f, 0.669739f, 0.670959f,
    0.67218f, 0.67337f, 0.674591f, 0.675781f, 0.677002f, 0.678192f,
    0.679413f, 0.680603f, 0.681793f, 0.682983f, 0.684204f, 0.685394f,
    0.686584f, 0.687775f, 0.688934f, 0.690125f, 0.691315f, 0.692505f,
    0.693665f, 0.694855f, 0.696045f, 0.697205f, 0.698364f, 0.699554f,
    0.700714f, 0.701874f, 0.703033f, 0.704193f, 0.705383f, 0.706543f,
    0.707672f, 0.708832f, 0.709991f, 0.711151f, 0.71228f, 0.71344f,
    0.7146f,    0.715729f, 0.716858f, 0.718018f, 0.719147f, 0.720276f,
    0.721436f, 0.722565f, 0.723694f, 0.724823f, 0.725952f, 0.727051f,
    0.72818f, 0.729309f, 0.730438f, 0.731537f, 0.732666f, 0.733765f,
    0.734863f, 0.735992f, 0.737091f, 0.73819f, 0.739288f, 0.740387f,
    0.741486f, 0.742584f, 0.743683f, 0.744781f, 0.74588f, 0.746979f,
    0.748047f, 0.749146f, 0.750214f, 0.751312f, 0.75238f, 0.753448f,
    0.754517f, 0.755615f, 0.756683f, 0.757751f, 0.75882f, 0.759888f,
    0.760925f, 0.761993f, 0.763062f, 0.764099f, 0.765167f, 0.766205f,
    0.767273f, 0.768311f, 0.769379f, 0.770416f, 0.771454f, 0.772491f,
    0.773529f, 0.774567f, 0.775604f, 0.776642f, 0.777649f, 0.778687f,
    0.779724f, 0.780731f, 0.781769f, 0.782776f, 0.783783f, 0.784821f,
    0.785828f, 0.786835f, 0.787842f, 0.788849f, 0.789856f, 0.790863f,
    0.79187f, 0.792847f, 0.793854f, 0.79483f, 0.795837f, 0.796814f,
    0.797821f, 0.798798f, 0.799774f, 0.800751f, 0.801758f, 0.802734f,
    0.80368f, 0.804657f, 0.805634f, 0.80661f, 0.807587f, 0.808533f,
    0.809509f, 0.810455f, 0.811401f, 0.812378f, 0.813324f, 0.81427f,
    0.815216f, 0.816162f, 0.817108f, 0.818054f, 0.819f,    0.819946f,
    0.820862f, 0.821808f, 0.822723f, 0.823669f, 0.824585f, 0.8255f,
    0.826447f, 0.827362f, 0.828278f, 0.829193f, 0.830109f, 0.831024f,
    0.831909f, 0.832825f, 0.83374f, 0.834625f, 0.835541f, 0.836426f,
    0.837341f, 0.838226f, 0.839111f, 0.839996f, 0.840881f, 0.841766f,
    0.842651f, 0.843536f, 0.844421f, 0.845276f, 0.846161f, 0.847046f,
    0.8479f,    0.848755f, 0.84964f, 0.850494f, 0.851349f, 0.852203f,
    0.853058f, 0.853912f, 0.854767f, 0.855621f, 0.856476f, 0.8573f,
    0.858154f, 0.858978f, 0.859833f, 0.860657f, 0.861481f, 0.862335f,
    0.863159f, 0.863983f, 0.864807f, 0.865631f, 0.866425f, 0.867249f,
    0.868073f, 0.868866f, 0.86969f, 0.870483f, 0.871307f, 0.872101f,
    0.872894f, 0.873688f, 0.874481f, 0.875275f, 0.876068f, 0.876862f,
    0.877655f, 0.878418f, 0.879211f, 0.879974f, 0.880768f, 0.881531f,
    0.882294f, 0.883087f, 0.88385f, 0.884613f, 0.885376f, 0.886139f,
    0.886871f, 0.887634f, 0.888397f, 0.88913f, 0.889893f, 0.890625f,
    0.891388f, 0.89212f, 0.892853f, 0.893585f, 0.894318f, 0.89505f,
    0.895782f, 0.896515f, 0.897247f, 0.897949f, 0.898682f, 0.899384f,
    0.900116f, 0.900818f, 0.90152f, 0.902222f, 0.902924f, 0.903625f,
    0.904327f, 0.905029f, 0.905731f, 0.906433f, 0.907104f, 0.907806f,
    0.908478f, 0.90918f, 0.909851f, 0.910522f, 0.911194f, 0.911865f,
    0.912537f, 0.913208f, 0.913879f, 0.914551f, 0.915192f, 0.915863f,
    0.916504f, 0.917175f, 0.917816f, 0.918457f, 0.919128f, 0.919769f,
    0.92041f, 0.921051f, 0.921661f, 0.922302f, 0.922943f, 0.923553f,
    0.924194f, 0.924805f, 0.925446f, 0.926056f, 0.926666f, 0.927277f,
    0.927887f, 0.928497f, 0.929108f, 0.929718f, 0.930328f, 0.930908f,
    0.931519f, 0.932098f, 0.932709f, 0.933289f, 0.933868f, 0.934448f,
    0.935028f, 0.935608f, 0.936188f, 0.936768f, 0.937347f, 0.937897f,
    0.938477f, 0.939026f, 0.939606f, 0.940155f, 0.940704f, 0.941254f,
    0.941833f, 0.942383f, 0.942902f, 0.943451f, 0.944f,    0.94455f,
    0.945068f, 0.945618f, 0.946136f, 0.946655f, 0.947205f, 0.947723f,
    0.948242f, 0.948761f, 0.94928f, 0.949799f, 0.950287f, 0.950806f,
    0.951294f, 0.951813f, 0.952301f, 0.95282f, 0.953308f, 0.953796f,
    0.954285f, 0.954773f, 0.955261f, 0.95575f, 0.956238f, 0.956696f,
    0.957184f, 0.957642f, 0.95813f, 0.958588f, 0.959045f, 0.959503f,
    0.959961f, 0.960419f, 0.960876f, 0.961334f, 0.961792f, 0.962219f,
    0.962677f, 0.963104f, 0.963562f, 0.963989f, 0.964417f, 0.964874f,
    0.965302f, 0.965729f, 0.966125f, 0.966553f, 0.96698f, 0.967407f,
    0.967804f, 0.968201f, 0.968628f, 0.969025f, 0.969421f, 0.969818f,
    0.970215f, 0.970612f, 0.971008f, 0.971405f, 0.971802f, 0.972168f,
    0.972565f, 0.972931f, 0.973328f, 0.973694f, 0.97406f, 0.974426f,
    0.974792f, 0.975159f, 0.975525f, 0.975891f, 0.976227f, 0.976593f,
    0.976929f, 0.977295f, 0.977631f, 0.977966f, 0.978333f, 0.978668f,
    0.979004f, 0.979309f, 0.979645f, 0.97998f, 0.980316f, 0.980621f,
    0.980957f, 0.981262f, 0.981567f, 0.981873f, 0.982208f, 0.982513f,
    0.982819f, 0.983093f, 0.983398f, 0.983704f, 0.983978f, 0.984283f,
    0.984558f, 0.984863f, 0.985138f, 0.985413f, 0.985687f, 0.985962f,
    0.986237f, 0.986511f, 0.986786f, 0.98703f, 0.987305f, 0.987549f,
    0.987823f, 0.988068f, 0.988312f, 0.988556f, 0.9888f,    0.989044f,
    0.989288f, 0.989532f, 0.989777f, 0.98999f, 0.990234f, 0.990448f,
    0.990692f, 0.990906f, 0.991119f, 0.991333f, 0.991547f, 0.99176f,
    0.991974f, 0.992188f, 0.992371f, 0.992584f, 0.992767f, 0.992981f,
    0.993164f, 0.993347f, 0.99353f, 0.993713f, 0.993896f, 0.99408f,
    0.994263f, 0.994446f, 0.994598f, 0.994781f, 0.994934f, 0.995117f,
    0.99527f, 0.995422f, 0.995575f, 0.995728f, 0.99588f, 0.996033f,
    0.996185f, 0.996307f, 0.99646f, 0.996582f, 0.996735f, 0.996857f,
    0.996979f, 0.997101f, 0.997223f, 0.997345f, 0.997467f, 0.997589f,
    0.997681f, 0.997803f, 0.997925f, 0.998016f, 0.998108f, 0.99823f,
    0.998322f, 0.998413f, 0.998505f, 0.998596f, 0.998657f, 0.998749f,
    0.99884f, 0.998901f, 0.998993f, 0.999054f, 0.999115f, 0.999207f,
    0.999268f, 0.999329f, 0.99939f, 0.999451f, 0.999481f, 0.999542f,
    0.999603f, 0.999634f, 0.999664f, 0.999725f, 0.999756f, 0.999786f,
    0.999817f, 0.999847f, 0.999878f, 0.999908f, 0.999939f, 0.999939f,
    0.999969f, 0.999969f, 0.999969f, 0.999969f, 0.999969f, 0.999969f,
};

static const float short_window[240] = {
    0.00326538f, 0.00982666f, 0.0163574f, 0.0229187f, 0.0294495f, 0.0359802f,
    0.0425415f, 0.0490723f, 0.055603f, 0.0621338f, 0.0686646f, 0.0751953f,
    0.0817261f, 0.0882568f, 0.0947571f, 0.101288f, 0.107788f, 0.114288f,
    0.120789f, 0.127289f, 0.133759f, 0.140259f, 0.146729f, 0.153198f,
    0.159668f, 0.166138f, 0.172577f, 0.179016f, 0.185455f, 0.191895f,
    0.198303f, 0.204712f, 0.211121f, 0.217499f, 0.223877f, 0.230255f,
    0.236633f, 0.242981f, 0.249329f, 0.255646f, 0.261993f, 0.26828f,
    0.274597f, 0.280884f, 0.28714f, 0.293427f, 0.299652f, 0.305908f,
    0.312134f, 0.318329f, 0.324524f, 0.330719f, 0.336884f, 0.343048f,
    0.349182f, 0.355316f, 0.36142f, 0.367523f, 0.373596f, 0.379669f,
    0.385712f, 0.391724f, 0.397736f, 0.403748f, 0.409729f, 0.41568f,
    0.421631f, 0.427551f, 0.433472f, 0.439362f, 0.445221f, 0.45108f,
    0.456909f, 0.462708f, 0.468506f, 0.474274f, 0.480042f, 0.485748f,
    0.491486f, 0.497162f, 0.502838f, 0.508484f, 0.514099f, 0.519714f,
    0.525299f, 0.530853f, 0.536377f, 0.541901f, 0.547394f, 0.552856f,
    0.558289f, 0.563721f, 0.569092f, 0.574463f, 0.579803f, 0.585144f,
    0.590424f, 0.595703f, 0.600952f, 0.606171f, 0.611359f, 0.616516f,
    0.621674f, 0.62677f, 0.631866f, 0.636932f, 0.641937f, 0.646942f,
    0.651947f, 0.656891f, 0.661804f, 0.666687f, 0.67157f, 0.676392f,
    0.681213f, 0.685974f, 0.690735f, 0.695435f, 0.700134f, 0.704803f,
    0.709412f, 0.71402f, 0.718567f, 0.723114f, 0.727631f, 0.732086f,
    0.736542f, 0.740936f, 0.745331f, 0.749664f, 0.753998f, 0.75827f,
    0.762512f, 0.766754f, 0.770935f, 0.775085f, 0.779205f, 0.783295f,
    0.787354f, 0.791351f, 0.795349f, 0.799286f, 0.803223f, 0.807098f,
    0.810944f, 0.814758f, 0.818512f, 0.822266f, 0.825989f, 0.829651f,
    0.833282f, 0.836884f, 0.840454f, 0.843964f, 0.847473f, 0.850922f,
    0.85434f, 0.857727f, 0.861084f, 0.86438f, 0.867645f, 0.87088f,
    0.874084f, 0.877258f, 0.880371f, 0.883453f, 0.886505f, 0.889526f,
    0.892487f, 0.895416f, 0.898315f, 0.901184f, 0.903992f, 0.906769f,
    0.909515f, 0.912201f, 0.914886f, 0.91748f, 0.920074f, 0.922607f,
    0.92514f, 0.927582f, 0.930023f, 0.932404f, 0.934753f, 0.937042f,
    0.939331f, 0.941559f, 0.943726f, 0.945862f, 0.947968f, 0.950043f,
    0.952057f, 0.954041f, 0.955994f, 0.957886f, 0.959747f, 0.961548f,
    0.963348f, 0.965088f, 0.966766f, 0.968414f, 0.970032f, 0.971588f,
    0.973114f, 0.974609f, 0.976074f, 0.977448f, 0.978821f, 0.980133f,
    0.981415f, 0.982666f, 0.983856f, 0.984985f, 0.986115f, 0.987183f,
    0.98819f, 0.989166f, 0.990112f, 0.990997f, 0.991852f, 0.992676f,
    0.993439f, 0.994171f, 0.994873f, 0.995514f, 0.996094f, 0.996643f,
    0.997162f, 0.99765f, 0.998077f, 0.998444f, 0.99881f, 0.999084f,
    0.999359f, 0.999573f, 0.999725f, 0.999878f, 0.999939f, 0.999969f,
};

static const int8_t dic4[256][8] = {
    {-2,  0,  0,  0,  0,  0,  0,  0}, { 0, -2,  0,  0,  0,  0,  0,  0},
    { 0,  0, -2,  0,  0,  0,  0,  0}, { 0,  0,  0, -2,  0,  0,  0,  0},
    { 0,  0,  0,  0, -2,  0,  0,  0}, { 0,  0,  0,  0,  0, -2,  0,  0},
    { 0,  0,  0,  0,  0,  0, -2,  0}, { 0,  0,  0,  0,  0,  0,  0, -2},
    { 2,  0,  0,  0,  0,  0,  0,  0}, { 0,  2,  0,  0,  0,  0,  0,  0},
    { 0,  0,  2,  0,  0,  0,  0,  0}, { 0,  0,  0,  2,  0,  0,  0,  0},
    { 0,  0,  0,  0,  2,  0,  0,  0}, { 0,  0,  0,  0,  0,  2,  0,  0},
    { 0,  0,  0,  0,  0,  0,  2,  0}, { 0,  0,  0,  0,  0,  0,  0,  2},
    {-2, -2,  0,  0,  0,  0,  0,  0}, {-2,  0, -2,  0,  0,  0,  0,  0},
    {-2,  0,  0, -2,  0,  0,  0,  0}, {-2,  0,  0,  0, -2,  0,  0,  0},
    {-2,  0,  0,  0,  0, -2,  0,  0}, {-2,  0,  0,  0,  0,  0, -2,  0},
    {-2,  0,  0,  0,  0,  0,  0, -2}, { 0, -2, -2,  0,  0,  0,  0,  0},
    { 0, -2,  0, -2,  0,  0,  0,  0}, { 0, -2,  0,  0, -2,  0,  0,  0},
    { 0, -2,  0,  0,  0, -2,  0,  0}, { 0, -2,  0,  0,  0,  0, -2,  0},
    { 0, -2,  0,  0,  0,  0,  0, -2}, { 0,  0, -2, -2,  0,  0,  0,  0},
    { 0,  0, -2,  0, -2,  0,  0,  0}, { 0,  0, -2,  0,  0, -2,  0,  0},
    { 0,  0, -2,  0,  0,  0, -2,  0}, { 0,  0, -2,  0,  0,  0,  0, -2},
    { 0,  0,  0, -2, -2,  0,  0,  0}, { 0,  0,  0, -2,  0, -2,  0,  0},
    { 0,  0,  0, -2,  0,  0, -2,  0}, { 0,  0,  0, -2,  0,  0,  0, -2},
    { 0,  0,  0,  0, -2, -2,  0,  0}, { 0,  0,  0,  0, -2,  0, -2,  0},
    { 0,  0,  0,  0, -2,  0,  0, -2}, { 0,  0,  0,  0,  0, -2, -2,  0},
    { 0,  0,  0,  0,  0, -2,  0, -2}, { 0,  0,  0,  0,  0,  0, -2, -2},
    {-2,  2,  0,  0,  0,  0,  0,  0}, {-2,  0,  2,  0,  0,  0,  0,  0},
    {-2,  0,  0,  2,  0,  0,  0,  0}, {-2,  0,  0,  0,  2,  0,  0,  0},
    {-2,  0,  0,  0,  0,  2,  0,  0}, {-2,  0,  0,  0,  0,  0,  2,  0},
    {-2,  0,  0,  0,  0,  0,  0,  2}, { 0, -2,  2,  0,  0,  0,  0,  0},
    { 0, -2,  0,  2,  0,  0,  0,  0}, { 0, -2,  0,  0,  2,  0,  0,  0},
    { 0, -2,  0,  0,  0,  2,  0,  0}, { 0, -2,  0,  0,  0,  0,  2,  0},
    { 0, -2,  0,  0,  0,  0,  0,  2}, { 0,  0, -2,  2,  0,  0,  0,  0},
    { 0,  0, -2,  0,  2,  0,  0,  0}, { 0,  0, -2,  0,  0,  2,  0,  0},
    { 0,  0, -2,  0,  0,  0,  2,  0}, { 0,  0, -2,  0,  0,  0,  0,  2},
    { 0,  0,  0, -2,  2,  0,  0,  0}, { 0,  0,  0, -2,  0,  2,  0,  0},
    { 0,  0,  0, -2,  0,  0,  2,  0}, { 0,  0,  0, -2,  0,  0,  0,  2},
    { 0,  0,  0,  0, -2,  2,  0,  0}, { 0,  0,  0,  0, -2,  0,  2,  0},
    { 0,  0,  0,  0, -2,  0,  0,  2}, { 0,  0,  0,  0,  0, -2,  2,  0},
    { 0,  0,  0,  0,  0, -2,  0,  2}, { 0,  0,  0,  0,  0,  0, -2,  2},
    { 2, -2,  0,  0,  0,  0,  0,  0}, { 2,  0, -2,  0,  0,  0,  0,  0},
    { 2,  0,  0, -2,  0,  0,  0,  0}, { 2,  0,  0,  0, -2,  0,  0,  0},
    { 2,  0,  0,  0,  0, -2,  0,  0}, { 2,  0,  0,  0,  0,  0, -2,  0},
    { 2,  0,  0,  0,  0,  0,  0, -2}, { 0,  2, -2,  0,  0,  0,  0,  0},
    { 0,  2,  0, -2,  0,  0,  0,  0}, { 0,  2,  0,  0, -2,  0,  0,  0},
    { 0,  2,  0,  0,  0, -2,  0,  0}, { 0,  2,  0,  0,  0,  0, -2,  0},
    { 0,  2,  0,  0,  0,  0,  0, -2}, { 0,  0,  2, -2,  0,  0,  0,  0},
    { 0,  0,  2,  0, -2,  0,  0,  0}, { 0,  0,  2,  0,  0, -2,  0,  0},
    { 0,  0,  2,  0,  0,  0, -2,  0}, { 0,  0,  2,  0,  0,  0,  0, -2},
    { 0,  0,  0,  2, -2,  0,  0,  0}, { 0,  0,  0,  2,  0, -2,  0,  0},
    { 0,  0,  0,  2,  0,  0, -2,  0}, { 0,  0,  0,  2,  0,  0,  0, -2},
    { 0,  0,  0,  0,  2, -2,  0,  0}, { 0,  0,  0,  0,  2,  0, -2,  0},
    { 0,  0,  0,  0,  2,  0,  0, -2}, { 0,  0,  0,  0,  0,  2, -2,  0},
    { 0,  0,  0,  0,  0,  2,  0, -2}, { 0,  0,  0,  0,  0,  0,  2, -2},
    { 2,  2,  0,  0,  0,  0,  0,  0}, { 2,  0,  2,  0,  0,  0,  0,  0},
    { 2,  0,  0,  2,  0,  0,  0,  0}, { 2,  0,  0,  0,  2,  0,  0,  0},
    { 2,  0,  0,  0,  0,  2,  0,  0}, { 2,  0,  0,  0,  0,  0,  2,  0},
    { 2,  0,  0,  0,  0,  0,  0,  2}, { 0,  2,  2,  0,  0,  0,  0,  0},
    { 0,  2,  0,  2,  0,  0,  0,  0}, { 0,  2,  0,  0,  2,  0,  0,  0},
    { 0,  2,  0,  0,  0,  2,  0,  0}, { 0,  2,  0,  0,  0,  0,  2,  0},
    { 0,  2,  0,  0,  0,  0,  0,  2}, { 0,  0,  2,  2,  0,  0,  0,  0},
    { 0,  0,  2,  0,  2,  0,  0,  0}, { 0,  0,  2,  0,  0,  2,  0,  0},
    { 0,  0,  2,  0,  0,  0,  2,  0}, { 0,  0,  2,  0,  0,  0,  0,  2},
    { 0,  0,  0,  2,  2,  0,  0,  0}, { 0,  0,  0,  2,  0,  2,  0,  0},
    { 0,  0,  0,  2,  0,  0,  2,  0}, { 0,  0,  0,  2,  0,  0,  0,  2},
    { 0,  0,  0,  0,  2,  2,  0,  0}, { 0,  0,  0,  0,  2,  0,  2,  0},
    { 0,  0,  0,  0,  2,  0,  0,  2}, { 0,  0,  0,  0,  0,  2,  2,  0},
    { 0,  0,  0,  0,  0,  2,  0,  2}, { 0,  0,  0,  0,  0,  0,  2,  2},
    {-1, -1,  1,  1,  1,  1,  1,  1}, {-1,  1, -1,  1,  1,  1,  1,  1},
    {-1,  1,  1, -1,  1,  1,  1,  1}, {-1,  1,  1,  1, -1,  1,  1,  1},
    {-1,  1,  1,  1,  1, -1,  1,  1}, {-1,  1,  1,  1,  1,  1, -1,  1},
    {-1,  1,  1,  1,  1,  1,  1, -1}, { 1, -1, -1,  1,  1,  1,  1,  1},
    { 1, -1,  1, -1,  1,  1,  1,  1}, { 1, -1,  1,  1, -1,  1,  1,  1},
    { 1, -1,  1,  1,  1, -1,  1,  1}, { 1, -1,  1,  1,  1,  1, -1,  1},
    { 1, -1,  1,  1,  1,  1,  1, -1}, { 1,  1, -1, -1,  1,  1,  1,  1},
    { 1,  1, -1,  1, -1,  1,  1,  1}, { 1,  1, -1,  1,  1, -1,  1,  1},
    { 1,  1, -1,  1,  1,  1, -1,  1}, { 1,  1, -1,  1,  1,  1,  1, -1},
    { 1,  1,  1, -1, -1,  1,  1,  1}, { 1,  1,  1, -1,  1, -1,  1,  1},
    { 1,  1,  1, -1,  1,  1, -1,  1}, { 1,  1,  1, -1,  1,  1,  1, -1},
    { 1,  1,  1,  1, -1, -1,  1,  1}, { 1,  1,  1,  1, -1,  1, -1,  1},
    { 1,  1,  1,  1, -1,  1,  1, -1}, { 1,  1,  1,  1,  1, -1, -1,  1},
    { 1,  1,  1,  1,  1, -1,  1, -1}, { 1,  1,  1,  1,  1,  1, -1, -1},
    {-1, -1, -1, -1,  1,  1,  1,  1}, {-1, -1, -1,  1, -1,  1,  1,  1},
    {-1, -1, -1,  1,  1, -1,  1,  1}, {-1, -1, -1,  1,  1,  1, -1,  1},
    {-1, -1, -1,  1,  1,  1,  1, -1}, {-1, -1,  1, -1, -1,  1,  1,  1},
    {-1, -1,  1, -1,  1, -1,  1,  1}, {-1, -1,  1, -1,  1,  1, -1,  1},
    {-1, -1,  1, -1,  1,  1,  1, -1}, {-1, -1,  1,  1, -1, -1,  1,  1},
    {-1, -1,  1,  1, -1,  1, -1,  1}, {-1, -1,  1,  1, -1,  1,  1, -1},
    {-1, -1,  1,  1,  1,  1, -1, -1}, {-1, -1,  1,  1,  1, -1,  1, -1},
    {-1, -1,  1,  1,  1, -1, -1,  1}, {-1,  1, -1, -1, -1,  1,  1,  1},
    {-1,  1, -1, -1,  1, -1,  1,  1}, {-1,  1, -1, -1,  1,  1, -1,  1},
    {-1,  1, -1, -1,  1,  1,  1, -1}, {-1,  1, -1,  1, -1, -1,  1,  1},
    {-1,  1, -1,  1, -1,  1, -1,  1}, {-1,  1, -1,  1, -1,  1,  1, -1},
    {-1,  1, -1,  1,  1,  1, -1, -1}, {-1,  1, -1,  1,  1, -1,  1, -1},
    {-1,  1, -1,  1,  1, -1, -1,  1}, {-1,  1,  1,  1,  1, -1, -1, -1},
    {-1,  1,  1,  1, -1,  1, -1, -1}, {-1,  1,  1,  1, -1, -1,  1, -1},
    {-1,  1,  1,  1, -1, -1, -1,  1}, {-1,  1,  1, -1, -1, -1,  1,  1},
    {-1,  1,  1, -1, -1,  1, -1,  1}, {-1,  1,  1, -1, -1,  1,  1, -1},
    {-1,  1,  1, -1,  1,  1, -1, -1}, {-1,  1,  1, -1,  1, -1,  1, -1},
    {-1,  1,  1, -1,  1, -1, -1,  1}, { 1,  1,  1,  1, -1, -1, -1, -1},
    { 1,  1,  1, -1,  1, -1, -1, -1}, { 1,  1,  1, -1, -1,  1, -1, -1},
    { 1,  1,  1, -1, -1, -1,  1, -1}, { 1,  1,  1, -1, -1, -1, -1,  1},
    { 1,  1, -1,  1,  1, -1, -1, -1}, { 1,  1, -1,  1, -1,  1, -1, -1},
    { 1,  1, -1,  1, -1, -1,  1, -1}, { 1,  1, -1,  1, -1, -1, -1,  1},
    { 1,  1, -1, -1,  1,  1, -1, -1}, { 1,  1, -1, -1,  1, -1,  1, -1},
    { 1,  1, -1, -1,  1, -1, -1,  1}, { 1,  1, -1, -1, -1, -1,  1,  1},
    { 1,  1, -1, -1, -1,  1, -1,  1}, { 1,  1, -1, -1, -1,  1,  1, -1},
    { 1, -1,  1,  1,  1, -1, -1, -1}, { 1, -1,  1,  1, -1,  1, -1, -1},
    { 1, -1,  1,  1, -1, -1,  1, -1}, { 1, -1,  1,  1, -1, -1, -1,  1},
    { 1, -1,  1, -1,  1,  1, -1, -1}, { 1, -1,  1, -1,  1, -1,  1, -1},
    { 1, -1,  1, -1,  1, -1, -1,  1}, { 1, -1,  1, -1, -1, -1,  1,  1},
    { 1, -1,  1, -1, -1,  1, -1,  1}, { 1, -1,  1, -1, -1,  1,  1, -1},
    { 1, -1, -1, -1, -1,  1,  1,  1}, { 1, -1, -1, -1,  1, -1,  1,  1},
    { 1, -1, -1, -1,  1,  1, -1,  1}, { 1, -1, -1, -1,  1,  1,  1, -1},
    { 1, -1, -1,  1,  1,  1, -1, -1}, { 1, -1, -1,  1,  1, -1,  1, -1},
    { 1, -1, -1,  1,  1, -1, -1,  1}, { 1, -1, -1,  1, -1, -1,  1,  1},
    { 1, -1, -1,  1, -1,  1, -1,  1}, { 1, -1, -1,  1, -1,  1,  1, -1},
    { 1,  1, -1, -1, -1, -1, -1, -1}, { 1, -1,  1, -1, -1, -1, -1, -1},
    { 1, -1, -1,  1, -1, -1, -1, -1}, { 1, -1, -1, -1,  1, -1, -1, -1},
    { 1, -1, -1, -1, -1,  1, -1, -1}, { 1, -1, -1, -1, -1, -1,  1, -1},
    { 1, -1, -1, -1, -1, -1, -1,  1}, {-1,  1,  1, -1, -1, -1, -1, -1},
    {-1,  1, -1,  1, -1, -1, -1, -1}, {-1,  1, -1, -1,  1, -1, -1, -1},
    {-1,  1, -1, -1, -1,  1, -1, -1}, {-1,  1, -1, -1, -1, -1,  1, -1},
    {-1,  1, -1, -1, -1, -1, -1,  1}, {-1, -1,  1,  1, -1, -1, -1, -1},
    {-1, -1,  1, -1,  1, -1, -1, -1}, {-1, -1,  1, -1, -1,  1, -1, -1},
    {-1, -1,  1, -1, -1, -1,  1, -1}, {-1, -1,  1, -1, -1, -1, -1,  1},
    {-1, -1, -1,  1,  1, -1, -1, -1}, {-1, -1, -1,  1, -1,  1, -1, -1},
    {-1, -1, -1,  1, -1, -1,  1, -1}, {-1, -1, -1,  1, -1, -1, -1,  1},
    {-1, -1, -1, -1,  1,  1, -1, -1}, {-1, -1, -1, -1,  1, -1,  1, -1},
    {-1, -1, -1, -1,  1, -1, -1,  1}, {-1, -1, -1, -1, -1,  1,  1, -1},
    {-1, -1, -1, -1, -1,  1, -1,  1}, {-1, -1, -1, -1, -1, -1,  1,  1},
    {-1, -1, -1, -1, -1, -1, -1, -1}, { 1,  1,  1,  1,  1,  1,  1,  1}
};

static const int16_t RV[10] = {
    0, 1, 4, 8, 16, 32, 64, 128, 256, 512
};

static const int16_t FacLVQ2Qv[10] = {
    0, 0, 11, 10, 9, 8, 7, 6, 5, 4
};

static const int16_t FacLVQ2Mask[10] = {
    0, 0, 2047, 1023, 511, 255, 127, 63, 31, 15
};

static const int16_t FacLVQ2HalfQv[10] = {
    0, 0, 1024, 512, 256, 128, 64, 32, 16, 8
};

static const float dicn[40]={ /* Codebook for quantization of norms */
    131072.0f, 92681.900024f,
    65536.0f,  46340.950012f,
    32768.0f,  23170.475006f,
    16384.0f,  11585.237503f,
    8192.0f,   5792.618751f,
    4096.0f,   2896.309376f,
    2048.0f,   1448.154688f,
    1024.0f,   724.077344f,
    512.0f,    362.038672f,
    256.0f,    181.019336f,
    128.0f,    90.509668f,
    64.0f,     45.254834f,
    32.0f,     22.627417f,
    16.0f,     11.313708f,
    8.0f,      5.656854f,
    4.0f,      2.828427f,
    2.0f,      1.414214f,
    1.0f,      0.707107f,
    0.5f,      0.353553f,
    0.25f,     0.176777f
};

static const int16_t huffoffset[6] = {
    0, 0, 0, 4, 12, 28,
};

static const int16_t sfm_start[44] = {
    0,   8,   16,  24,  32,  40,  48,  56,  64,  72,  80,
    88,  96,  104, 112, 120, 128, 144, 160, 176, 192, 208,
    224, 240, 256, 280, 304, 328, 352, 376, 400, 424, 448,
    472, 496, 520, 544, 576, 608, 640, 672, 704, 736, 768,
};

static const int16_t sfm_end[44] = {
    8,  16,  24,  32,  40,  48,  56,  64,  72,  80,  88,
    96, 104, 112, 120, 128, 144, 160, 176, 192, 208, 224,
    240, 256, 280, 304, 328, 352, 376, 400, 424, 448, 472,
    496, 520, 544, 576, 608, 640, 672, 704, 736, 768, 800,
};

static const int16_t sfmsize[44] = {
    8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,  8,
    16, 16, 16, 16, 16, 16, 16, 16,
    24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
    32, 32, 32, 32, 32, 32, 32, 32
};

static const int16_t sfm_width[20] = {
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 5, 5, 6, 6, 6, 7, 8
};

static const int16_t a[20] = {
    8, 6, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 5, 7, 11
};

static const uint8_t huffsizn[32] = {
    7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 4, 4, 3, 3,
    3, 3, 4, 4, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7
};

static const int16_t huffsizc[60] = {
    1, 3, 3, 2,
    2, 2, 4, 5, 5, 4, 4, 2,
    2, 3, 4, 4, 5, 5, 5, 6, 6, 5, 5, 5, 5, 4, 4, 3,
    2, 3, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 5, 5, 4, 3
};

static const int8_t dicnlg2[40] = {
    34, 33, 32, 31, 30, 29, 28, 27, 26, 25,
    24, 23, 22, 21, 20, 19, 18, 17, 16, 15,
    14, 13, 12, 11, 10,  9,  8,  7,  6,  5,
    4,  3,  2,  1,  0, -1, -2, -3, -4, -5
};

typedef struct ChannelState {
    DECLARE_ALIGNED(32, float, imdct_in)[FRAME_LENGTH];
    DECLARE_ALIGNED(32, float, imdct_out)[FRAME_LENGTH];
    DECLARE_ALIGNED(32, float, imdct_prev)[FRAME_LENGTH];
    DECLARE_ALIGNED(32, float, imdct_sout)[240];
    DECLARE_ALIGNED(32, float, imdct_sprev)[240];

    float audio_q_norm[FREQ_LENGTH];
    float codebook[FREQ_LENGTH];
    float coefs_short[STOP_BAND];
    int16_t bitalloc[NB_SFM];
    int16_t ynrm[NB_SFM];
    int16_t ycof[STOP_BAND];

    float   old_hpfilt_in;
    float   old_hpfilt_out;
    float   energy_lt;
    int16_t transient_hang_over;

    int16_t nf_idx;
    int is_transient;
    int old_is_transient;
} ChannelState;

typedef struct G719Context {
    GetBitContext gb;

    int num_bits;
    int num_bits_spectrum_stationary;
    int num_bits_spectrum_transient;

    ChannelState       ch[2];

    av_tx_fn           ltx_fn;
    av_tx_fn           stx_fn;
    AVTXContext       *ltx_ctx;
    AVTXContext       *stx_ctx;
    AVFloatDSPContext *fdsp;
} G719Context;

static av_cold int decode_init(AVCodecContext *avctx)
{
    G719Context *s = avctx->priv_data;
    float scale = 1.f / (32768.f * 22.f);
    int ret;

    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;

    if (avctx->channels <= 0 || avctx->channels > 2)
        return AVERROR(EINVAL);

    s->num_bits                     = (avctx->block_align / avctx->channels) * 8;
    s->num_bits_spectrum_stationary = s->num_bits - 3;
    s->num_bits_spectrum_transient  = s->num_bits - 1;

    s->fdsp = avpriv_float_dsp_alloc(avctx->flags & AV_CODEC_FLAG_BITEXACT);
    if (!s->fdsp)
        return AVERROR(ENOMEM);

    ret = av_tx_init(&s->ltx_ctx, &s->ltx_fn, AV_TX_FLOAT_MDCT, 1, 960, &scale, 0);
    if (ret < 0)
        return ret;
    return av_tx_init(&s->stx_ctx, &s->stx_fn, AV_TX_FLOAT_MDCT, 1, 240, &scale, 0);
}

static void bits2idxn(AVCodecContext *avctx,
                      int16_t N, int16_t *x)
{
    G719Context *s = avctx->priv_data;
    GetBitContext *gb = &s->gb;

    *x = 0;
    for (int i = 0; i < N; i++) {
        *x <<= 1;
        if (get_bits1(gb))
            *x = *x + 1;
    }
}

static void hdecnrm(AVCodecContext *avctx, int16_t N, int16_t *index)
{
    G719Context *s = avctx->priv_data;
    GetBitContext *gb = &s->gb;
    int16_t i, j, k, n, m;
    int16_t temp;
    int16_t *pidx;

    pidx  = index;

    m = N - 1;
    for (i=0; i<m; i++)
    {
        j = 0;
        k = 0;
        if (get_bits1(gb))
            j = 1;
        if (get_bits1(gb))
            k = 1;
        n = j * 2 + k;
        j = j * 4;
        temp = 16 + n - j;
        if (get_bits1(gb)) {
            temp = 12 + n + j;
            if (get_bits1(gb))
            {
                j = get_bits1(gb);
                temp = 8 + n + j * 12;
                if (get_bits1(gb)) {
                    temp = n;
                    if (get_bits1(gb))
                        temp = n + 4;
                    if (j!=0)
                        temp += 24;
                }
            }
        }
        *pidx++ = temp;
    }

}

static void recovernorm(int16_t *idxbuf, int16_t *ynrm, int16_t *normqlg2)
{
    int16_t i;
    int16_t *pidx, *pnormq;

    for (i=0; i<2; i++)
    {
        pidx = ynrm + i;
        pnormq = normqlg2 + i;
        *pidx = idxbuf[i];
        *pnormq = dicnlg2[*pidx];
        pidx += 2;
        pnormq += 2;
        *pidx = idxbuf[21-i];
        *pnormq = dicnlg2[*pidx];
        pidx += 2;
        pnormq += 2;
        *pidx = idxbuf[22+i];
        *pnormq = dicnlg2[*pidx];
        pidx += 2;
        pnormq += 2;
        *pidx = idxbuf[43-i];
        *pnormq = dicnlg2[*pidx];
        pidx += 2;
        pnormq += 2;
        *pidx  = idxbuf[i+2];
        *pnormq = dicnlg2[*pidx];
        pidx += 2;
        pnormq += 2;
        *pidx = idxbuf[19-i];
        *pnormq = dicnlg2[*pidx];
        pidx += 2;
        pnormq += 2;
        *pidx = idxbuf[24+i];
        *pnormq = dicnlg2[*pidx];
        pidx += 2;
        pnormq += 2;
        *pidx = idxbuf[41-i];
        *pnormq = dicnlg2[*pidx];
    }

    pidx = ynrm + 16;
    pnormq = normqlg2 + 16;
    for (i=4; i<(NB_SFM/4); i++)
    {
        *pidx = idxbuf[i];
        *pnormq++ = dicnlg2[*pidx++];
        *pidx = idxbuf[21-i];
        *pnormq++ = dicnlg2[*pidx++];
        *pidx = idxbuf[22+i];
        *pnormq++ = dicnlg2[*pidx++];
        *pidx = idxbuf[43-i];
        *pnormq++ = dicnlg2[*pidx++];
    }
}

static void sfm2mqb(int16_t spe[], int16_t spe2q[])
{
    int16_t tmp,i;

    /* int16_t groups */
    spe2q[0]  = spe[0] + 3;
    spe2q[1]  = spe[1] + 3;
    spe2q[2]  = spe[2] + 3;
    spe2q[3]  = spe[3] + 3;
    spe2q[4]  = spe[4] + 3;
    spe2q[5]  = spe[5] + 3;
    spe2q[6]  = spe[6] + 3;
    spe2q[7]  = spe[7] + 3;
    spe2q[8]  = spe[8] + 3;
    spe2q[9]  = spe[9] + 3;

    spe2q[10]  = ((spe[10] + spe[11]) >> 1) + 4;
    spe2q[11]  = ((spe[12] + spe[13]) >> 1) + 4;
    spe2q[12]  = ((spe[14] + spe[15]) >> 1) + 4;

    spe2q[13]  = ((spe[16] + spe[17]) >> 1) + 5;
    spe2q[14]  = ((spe[18] + spe[19]) >> 1) + 5;

    tmp = 0;
    for (i=20; i < 24; i++)
    {
        tmp += spe[i];
    }
    spe2q[15] = (int16_t)(((int)tmp * 8192L) >> 15) + 6;

    tmp = 0;
    for (i=24; i < 27; i++)
    {
        tmp += spe[i];
    }
    spe2q[16] = (int16_t)(((int)tmp * 10923L) >> 15) + 6;

    tmp = 0;
    for (i=27; i < 30; i++)
    {
        tmp += spe[i];
    }
    spe2q[17] = (int16_t)(((int)tmp * 10923L) >> 15) + 6;

    tmp = 0;
    for (i=30; i < 35; i++)
    {
        tmp += spe[i];
    }
    spe2q[18] = (int16_t)(((int)tmp * 6553L) >> 15) + 7;

    tmp = 0;
    for (i=35; i < 44; i++) {
        tmp += spe[i];
    }
    spe2q[19] = (int16_t)(((int)tmp * 3641L) >> 15) + 8;
}

static void mqb2sfm(int16_t spe2q[],int16_t spe[])
{
    int16_t i;

    spe[0]  = spe2q[0];
    spe[1]  = spe2q[1];
    spe[2]  = spe2q[2];
    spe[3]  = spe2q[3];
    spe[4]  = spe2q[4];
    spe[5]  = spe2q[5];
    spe[6]  = spe2q[6];
    spe[7]  = spe2q[7];
    spe[8]  = spe2q[8];
    spe[9]  = spe2q[9];

    spe[10] = spe2q[10];
    spe[11] = spe2q[10];

    spe[12] = spe2q[11];
    spe[13] = spe2q[11];

    spe[14] = spe2q[12];
    spe[15] = spe2q[12];

    spe[16] = spe2q[13];
    spe[17] = spe2q[13];

    spe[18] = spe2q[14];
    spe[19] = spe2q[14];

    for (i=20; i < 24; i++)
    {
        spe[i] = spe2q[15];
    }

    for (i=24; i < 27; i++)
    {
        spe[i] = spe2q[16];
    }

    for (i=27; i < 30; i++)
    {
        spe[i] = spe2q[17];
    }

    for (i=30; i < 35; i++)
    {
        spe[i] = spe2q[18];
    }

    for (i=35; i < 44; i++)
    {
        spe[i] = spe2q[19];
    }
}

static void map_quant_weight(int16_t normqlg2[], int16_t wnorm[], int is_transient)
{
    int16_t sfm;
    int16_t tmp16;
    int16_t spe2q[NUM_MAP_BANDS];
    int16_t spe[NB_SFM];

    int16_t spe2q_max;
    int16_t spe2q_min;
    int16_t norm_max;
    int16_t shift;
    int16_t sum;
    int16_t k;

    if (is_transient)
    {
        for (sfm = 0; sfm < NB_SFM; sfm+=4)
        {
            sum = 0;
            for (k=0; k < 4; k++) {
                sum = sum + normqlg2[sfm+k];
            }
            sum = sum >> 2;

            for (k=0; k < 4; k++)
            {
                spe[sfm +k] = sum;
            }
        }
    }
    else {
        for (sfm = 0; sfm < NB_SFM; sfm++)
        {
            spe[sfm] = normqlg2[sfm];
        }
    }

    sfm2mqb(spe, spe2q);

    for (sfm = 0; sfm < NUM_MAP_BANDS; sfm++)
    {
        spe2q[sfm] = spe2q[sfm] - 10;
    }

    /* spectral smoothing */
    for (sfm = 1; sfm < NUM_MAP_BANDS; sfm++)
    {
        tmp16 = spe2q[sfm-1] - 4;
        if (spe2q[sfm]<tmp16)
        {
            spe2q[sfm] = tmp16;
        }
    }

    for (sfm = NUM_MAP_BANDS-2; sfm >= 0; sfm--)
    {
        tmp16 = spe2q[sfm+1] - 8;
        if (spe2q[sfm]<tmp16)
        {
            spe2q[sfm] = tmp16;
        }
    }
    for (sfm = 0; sfm < NUM_MAP_BANDS; sfm++)
    {
        if (spe2q[sfm]<a[sfm])
        {
            spe2q[sfm] = a[sfm];
        }
    }

    /* Saturate by the Absolute Threshold of Hearing */
    spe2q_max = MIN16B;
    spe2q_min = MAX16B;

    for (sfm = 0; sfm < NUM_MAP_BANDS; sfm++)
    {
        spe2q[sfm] = sfm_width[sfm] - spe2q[sfm];
        if (spe2q_max<spe2q[sfm])
        {
            spe2q_max = spe2q[sfm];
        }
        if (spe2q_min>spe2q[sfm])
        {
            spe2q_min = spe2q[sfm];
        }
    }

    for (sfm = 0; sfm < NUM_MAP_BANDS; sfm++)
    {
        spe2q[sfm] = spe2q[sfm] - spe2q_min;
    }

    spe2q_max = spe2q_max - spe2q_min;

    if (spe2q_max==0)
    {
        norm_max = 0;
    }
    else
    {
        if (spe2q_max<0)
        {
            spe2q_max = ~spe2q_max;
        }
        for (norm_max=0; spe2q_max<0x4000; norm_max++)
        {
            spe2q_max <<= 1;
        }
    }

    shift = norm_max - 13;

    for (sfm = 0; sfm < NUM_MAP_BANDS; sfm++)
    {
        if (shift<0)
        {
            spe2q[sfm] = spe2q[sfm] >> (-shift);
        }
        else
        {
            spe2q[sfm] = spe2q[sfm] << shift;
        }
    }

    mqb2sfm(spe2q,spe);

    if (is_transient)
    {
        for (sfm = 0; sfm < NB_SFM; sfm+=4)
        {
            sum = 0;
            for (k=0; k < 4; k++) {
                sum = sum + spe[sfm+k];
            }
            sum = sum >> 2;

            for (k=0; k < 4; k++)
            {
                spe[sfm +k] = sum;
            }
        }
    }

    /* modify the norms for bit-allocation */
    for (sfm = 0; sfm < NB_SFM; sfm++)
    {
        wnorm[sfm] = spe[sfm] + normqlg2[sfm];
    }

}

static void bitalloc(int16_t *y, int16_t *idx, int16_t sum, int16_t N, int16_t M, int16_t *r)
{
    int16_t i, j, k, n, m, v, im;
    int16_t diff, temp;

    im = 1;
    diff = sum;
    n = sum >> 3;
    for (i=0; i<n; i++)
    {
        k = 0;
        temp = y[0];
        for (m=1; m<=im; m++)
        {
            if (temp<y[m])
            {
                temp = y[m];
                k = m;
            }
        }
        if (k==im)
        {
            im++;
        }
        j = idx[k];
        if ((sum>=sfmsize[j]) && (r[j]<M))
        {
            y[k] -= 2;
            r[j]++;
            if (r[j]>=M)
            {
                y[k] = MIN16B;
            }
            sum -= sfmsize[j];
        }
        else
        {
            y[k] = MIN16B;
            k++;
            if (k==im)
            {
                im++;
            }
        }
        if ((sum<WID_G1) || (diff==sum))
        {
            break;
        }
        diff = sum;
        v = N - 2;
        if (k>v)
        {
            for (i=0; i<N; i++)
            {
                if (y[i]>MIN16B)
                {
                    im = i + 1;
                    break;
                }
            }
        }
    }
    if (sum>=WID_G2)
    {
        for (i=0; i<N; i++)
        {
            j = idx[i];
            if ((j>=SFM_G1) && (j<SFM_G1G2) && (r[j]==0))
            {
                r[j] = 1;
                sum -= WID_G2;
                if (sum<WID_G2)
                {
                    break;
                }
            }
        }
    }
    if (sum>=WID_G2)
    {
        for (i=0; i<N; i++)
        {
            j = idx[i];
            if ((j>=SFM_G1) && (j<SFM_G1G2) && (r[j]==1))
            {
                r[j] = 2;
                sum -= WID_G2;
                if (sum<WID_G2)
                {
                    break;
                }
            }
        }
    }
    if (sum>=WID_G1)
    {
        for (i=0; i<N; i++)
        {
            j = idx[i];
            if ((j<SFM_G1) && (r[j]==0))
            {
                r[j] = 1;
                sum -= WID_G1;
                if (sum<WID_G1)
                {
                    break;
                }
            }
        }
    }
    if (sum>=WID_G1)
    {
        for (i=0; i<N; i++)
        {
            j = idx[i];
            if ((j<SFM_G1) && (r[j]==1))
            {
                r[j] = 2;
                sum -= WID_G1;
                if (sum<WID_G1)
                {
                    break;
                }
            }
        }
    }
}

static void reordvct(int16_t *y, int16_t N, int16_t *idx)
{
    int16_t i, j, k, n, im, temp;

    n = N - 1;
    for (i=0; i<n; i++)
    {
        im = i;
        k = i + 1;
        for (j=k; j<N; j++)
        {
            temp = y[im] - y[j];
            if (temp<0)
            {
                im = j;
            }
        }
        temp = y[i];
        y[i] = y[im];
        y[im] = temp;
        j = idx[i];
        idx[i] = idx[im];
        idx[im] = j;
    }
}

static void bits2idxc(AVCodecContext *avctx, int16_t N, int16_t L, int16_t *x)
{
    G719Context *s = avctx->priv_data;
    GetBitContext *gb = &s->gb;
    int16_t i, k, m, n;
    int16_t temp;

    if (L==1)
    {
        n = 1;
        m = N;
    }
    else
    {
        n = N;
        m = L;
    }

    for (k=0; k<n; k++)
    {
        x[k] = 0;
        for (i=0; i<m; i++)
        {
            temp = x[k] << 1;
            temp += get_bits1(gb);
            x[k] = temp;
        }
    }
}

static void hdec2blvq(AVCodecContext *avctx,
                      int16_t N, int16_t *index)
{
    G719Context *s = avctx->priv_data;
    GetBitContext *gb = &s->gb;
    int16_t temp;
    int16_t *pidx;

    pidx  = index;
    for (int i=0; i<N; i++) {
        temp = 0;
        if (get_bits1(gb))
        {
            temp = 3;
            if (get_bits1(gb))
            {
                temp = 1;
                if (get_bits1(gb))
                {
                    temp++;
                }
            }
        }
        *pidx++ = temp;
    }
}

static void hdec4blvq(AVCodecContext *avctx, int16_t N, int16_t *index)
{
    G719Context *s = avctx->priv_data;
    GetBitContext *gb = &s->gb;
    int16_t i, j, k, m;
    int16_t temp;
    int16_t *pidx;

    pidx  = index;

    for (i=0; i<N; i++)
    {
        k = 0;
        if (get_bits1(gb))
        {
            k = 2;
        }
        if (get_bits1(gb))
        {
            k++;
        }
        temp = 0;
        if (k!=0)
        {
            j = 0;
            if (get_bits1(gb))
            {
                j = 1;
            }
            temp = 1;
            if (j!=0)
            {
                temp = 15;
            }
            if (k!=3)
            {
                m = j * 2;
                if (get_bits1(gb))
                {
                    m++;
                }
                temp = m;
                if (j==0)
                {
                    temp = m + 13;
                }
                if (k!=1)
                {
                    m = m * 2;
                    if (get_bits1(gb))
                    {
                        m++;
                    }
                    temp = m;
                    if (j==0)
                    {
                        temp = m + 9;
                    }
                    if (m==7)
                    {
                        temp = m;
                        if (get_bits1(gb))
                        {
                            temp = m + 1;
                        }
                    }
                }
            }
        }
        *pidx++ = temp;
    }
}

static void hdec3blvq(AVCodecContext *avctx, int16_t N, int16_t *index)
{
    G719Context *s = avctx->priv_data;
    GetBitContext *gb = &s->gb;
    int16_t j, k, m;
    int16_t temp;
    int16_t *pidx;

    pidx  = index;
    for (int i = 0; i < N; i++) {
        j = get_bits1(gb);
        k = j * 2;
        if (get_bits1(gb))
        {
            k++;
        }
        temp = j * 4 + k;
        if (k==2)
        {
            j = 0;
            if (get_bits1(gb))
            {
                j = 1;
            }
            m = j * 2;
            if (get_bits1(gb))
            {
                m++;
            }
            temp = j * 2 + m + 1;
            if (m==0)
            {
                temp = 3;
                if (get_bits1(gb))
                {
                    temp++;
                }
            }
        }
        *pidx++ = temp;
    }
}

static void hdec5blvq(AVCodecContext *avctx,
                      int16_t N, int16_t *index)
{
    G719Context *s = avctx->priv_data;
    GetBitContext *gb = &s->gb;
    int16_t j, k, m, n;
    int16_t temp;
    int16_t *pidx;

    pidx  = index;
    for (int i=0; i<N; i++)
    {
        n = 0;
        if (get_bits1(gb))
        {
            n = 2;
        }
        if (get_bits1(gb))
        {
            n++;
        }
        temp = 0;
        if (n!=0)
        {
            j = 0;
            if (get_bits1(gb))
            {
                j = 1;
            }
            temp = 1;
            if (j!=0)
            {
                temp = 31;
            }
            if (n!=1)
            {
                k = 0;
                if (get_bits1(gb))
                {
                    k = 1;
                }
                if (n==2)
                {
                    temp = 2;
                    if (k!=0)
                    {
                        temp = 30;
                    }
                    if (j!=0)
                    {
                        temp = 3;
                        if (get_bits1(gb))
                        {
                            temp++;
                        }
                        if (k!=0)
                        {
                            temp += 25;
                        }
                    }
                }
                else
                {
                    m = 0;
                    if (get_bits1(gb))
                    {
                        m = 2;
                    }
                    if (get_bits1(gb))
                    {
                        m++;
                    }
                    temp = m + 5;
                    if (k!=0)
                    {
                        temp += 19;
                    }
                    if (j!=0)
                    {
                        m = k * 4 + m;
                        temp = 23;
                        if (m!=7)
                        {
                            m *= 2;
                            if (get_bits1(gb))
                            {
                                m++;
                            }
                            temp = m + 9;
                        }
                    }
                }
            }
        }
        *pidx++ = temp;
    }
}

static int16_t unpackc(AVCodecContext *avctx,
                       int16_t *R,
                       int16_t flag, int16_t rv,
                       int16_t N1, int16_t N2,
                       int16_t L, int16_t *y)
{
    int16_t i, j, k, n, r, v, hcode_l, offset, sum;
    int16_t nb_vecs, length;

    nb_vecs = L >> 3;
    length = 0;
    if (flag==NOHUFCODE)
    {
        for (n=N1; n<N2; n++)
        {
            v = R[n];
            if (v>1)
            {
                bits2idxc(avctx, L, v, &y[rv]);
                sum = v * L;
                length += sum;
            }
            else if (v==1)
            {
                k = rv;
                for (i=0; i<nb_vecs; i++)
                {
                    bits2idxc(avctx, 8, 1, &y[k]);
                    k += 8;
                }
                length += L;
            }
            rv += L;
        }
    }
    else
    {
        r = 0;
        hcode_l = 0;
        for (n=N1; n<N2; n++)
        {
            v = R[n];
            if (v>QBIT_MAX1)
            {
                bits2idxc(avctx, L, v, &y[rv]);
                sum = v * L;
                r += sum;
            }
            else if (v>1)
            {
                if (v==2)
                {
                    hdec2blvq(avctx, L, &y[rv]);
                }
                else if (v==3)
                {
                    hdec3blvq(avctx, L, &y[rv]);
                }
                else if (v==4)
                {
                    hdec4blvq(avctx, L, &y[rv]);
                }
                else
                {
                    hdec5blvq(avctx, L, &y[rv]);
                }
                offset = huffoffset[v];
                for (i=0; i<L; i++)
                {
                    k = rv + i;
                    j = offset + y[k];
                    hcode_l += huffsizc[j];
                }
            }
            else if (v==1)
            {
                k = rv;
                for (i=0; i<nb_vecs; i++)
                {
                    bits2idxc(avctx, 8, 1, &y[k]);
                    k += 8;
                }
                r += L;
            }
            rv += L;
        }
        length = hcode_l + r;
    }

    return(length);
}

static void codesearch(int16_t *x, int16_t *C, int16_t R)
{
    int16_t i, j, sum;
    int16_t e[8], em, temp;

    sum = 0;
    for (i=0; i<8; i++)
    {
        temp = x[i] & FacLVQ2Mask[R];
        C[i] = x[i] >> FacLVQ2Qv[R];
        if ((temp>FacLVQ2HalfQv[R]) || ((temp==FacLVQ2HalfQv[R]) && (x[i]<0)))
        {
            C[i] += 1;
        }
        sum += C[i];
    }
    if (sum&1)
    {
        j = 0;
        em = 0;
        for (i=0; i<8; i++)
        {
            temp = C[i] << FacLVQ2Qv[R];
            e[i] = x[i] - temp;
            temp = e[i];
            if (e[i]<0)
            {
                temp = -e[i];
            }
            if (em<temp)
            {
                em = temp;
                j = i;
            }
        }
        if (e[j]>=0)
        {
            C[j] += 1;
        }
        else
        {
            C[j] -= 1;
        }
    }
}

static void idx2code(int16_t *k, int16_t *y, int16_t R)
{
    int16_t i, m, tmp;
    int16_t v[8], z[8];

    tmp = FacLVQ2Qv[R] - R;
    m = k[0] << 1;
    for (i=1; i<8; i++)
    {
        m += k[i];
    }
    if (tmp<0)
    {
        z[0] = m >> (-tmp);
    }
    else
    {
        z[0] = m << tmp;
    }
    for (i=1; i<8; i++)
    {
        if (tmp<0)
        {
            z[i] = k[i] >> (-tmp);
        }
        else
        {
            z[i] = k[i] << tmp;
        }
    }
    codesearch(z, v, R);
    y[0] = m - (v[0] << R);
    for (i=1; i<8; i++)
    {
        y[i] = k[i] - (v[i] << R);
    }
}

static void dqcoefs(int16_t *y, int16_t *idxnrm, int16_t *R, int16_t N1,
                    int16_t N2, int16_t L, float *coefs, float *coefs_norm)
{
    int16_t v, rv;
    int16_t nb_vecs, pre_idx;
    int16_t x[8];
    float normq, factor;
    int16_t *pidx;
    float *pcoefs, *pcoefs_norm;

    pidx = y;
    pcoefs = coefs;
    pcoefs_norm = coefs_norm;
    nb_vecs = L >> 3;
    for (int n = N1; n < N2; n++) {
        av_assert0(idxnrm[n] < 40 && idxnrm[n] >= 0);
        normq = dicn[idxnrm[n]];
        v = R[n];
        if (v > 1) {
            rv = RV[v];
            factor = FCT_LVQ2f / (float)rv;
            for (int i = 0; i < nb_vecs; i++) {
                idx2code(pidx, x, v);
                for (int j = 0; j < 8; j++) {
                    *pcoefs_norm = x[j] * factor + OFFSETf;
                    *pcoefs = (*pcoefs_norm) * normq;
                    pcoefs_norm++;
                    pcoefs++;
                }
                pidx += 8;
            }
        } else if (v == 1) {
            pre_idx = MAX16B;
            for (int i=0; i<nb_vecs; i++) {
                if ((pre_idx<128) && (*pidx<16)) {
                    for (int j = 0; j < 8; j++) {
                        *pcoefs_norm = OFFSETf;
                        *pcoefs = (*pcoefs_norm) * normq;
                        pcoefs_norm++;
                        pcoefs++;
                    }
                } else {
                    for (int j = 0; j < 8; j++) {
                        *pcoefs_norm = (float)dic4[*pidx][j] / FCT_LVQ1f + OFFSETf;
                        *pcoefs = (*pcoefs_norm) * normq;
                        pcoefs_norm++;
                        pcoefs++;
                    }
                }
                pre_idx = *pidx;
                pidx += 8;
            }
        } else {
            for (int i = 0; i < L; i++) {
                *pcoefs_norm = 0.f;
                pcoefs_norm++;
                *pcoefs = 0.f;
                pcoefs++;
            }
            pidx += L;
        }
    }
}

static void dprocnf(AVCodecContext *avctx, int16_t *y,
                    int16_t idxnrm, int16_t nb_vecs,
                    float *coefs, float* coefs_norm)
{
    int16_t i, j;
    int16_t pre_idx;
    float normq;

    normq = dicn[idxnrm];
    pre_idx = MAX16B;
    for (i=0; i<nb_vecs; i++)
    {
        bits2idxc(avctx, 8, 1, y);
        if ((pre_idx<128) && (*y<16))
        {
            for (j=0; j<8; j++)
            {
                *coefs_norm = OFFSETf;
                *coefs++ = (*coefs_norm++) * normq;
            }
        }
        else
        {
            for (j=0; j<8; j++)
            {
                *coefs_norm = (float)dic4[*y][j] / FCT_LVQ1f + OFFSETf;
                *coefs++ = (*coefs_norm++) * normq;
            }
        }
        pre_idx = *y;
        y += 8;
    }
}

static void dprocnobitsbfm(AVCodecContext *avctx, int16_t *R, int16_t *idx,
                           int16_t *ynrm, int16_t *ycof,
                           float *coefsq, float *coefsq_norm,
                           int16_t nb_sfm, int16_t diff)
{
    int16_t k, m, im, offset;

    im = MAX16B;
    k = nb_sfm - 1;

    for (int i = k; i > 0; i--) {
        if (R[idx[i]] == 0)
            im = i;
    }

    for (int i = im; i < nb_sfm; i++) {
        m = idx[i];

        if (R[m])
            continue;

        if (m < SFM_G1) {
            if (diff >= WID_G1) {
                R[m] = 1;
                offset = m * WID_G1;
                dprocnf(avctx, &ycof[offset], ynrm[m], NB_VECT1, &coefsq[offset], &coefsq_norm[offset]);
                diff -= WID_G1;
            }
        } else if (m < SFM_G1G2) {
            if (diff >= WID_G2) {
                R[m] = 1;
                offset = NUMC_G1 + (m - SFM_G1) * WID_G2;
                dprocnf(avctx, &ycof[offset], ynrm[m], NB_VECT2, &coefsq[offset], &coefsq_norm[offset]);
                diff -= WID_G2;
            }
        } else if (m < SFM_N) {
            if (diff >= WID_G3) {
                R[m] = 1;
                offset = NUMC_G1G2 + (m - SFM_G1G2) * WID_G3;
                dprocnf(avctx, &ycof[offset], ynrm[m], NB_VECT3, &coefsq[offset], &coefsq_norm[offset]);
                diff -= WID_G3;
            }
        } else {
            if (diff >= WID_GX) {
                R[m] = 1;
                offset = NUMC_N + (m - SFM_N) * WID_GX;
                dprocnf(avctx, &ycof[offset], ynrm[m], NB_VECTX, &coefsq[offset], &coefsq_norm[offset]);
                diff -= WID_GX;
            }
        }
    }
}

static int flvqdec(AVCodecContext *avctx, ChannelState *c,
                    float *coefsq_norm, int16_t *R,
                    int16_t NumSpectumBits,
                    int16_t *ynrm, int16_t is_transient)
{
    G719Context *s = avctx->priv_data;
    GetBitContext *gb = &s->gb;
    int16_t k, v, nb_sfm;
    int16_t diff;
    int16_t hcode_l, FlagL, FlagN, FlagC;
    int16_t idx[NB_SFM], normqlg2[NB_SFM], wnorm[NB_SFM], idxbuf[NB_SFM];

    FlagL = get_bits1(gb);
    FlagN = get_bits1(gb);
    FlagC = get_bits1(gb);

    nb_sfm = FlagL == NOALLGROUPS ? SFM_N : NB_SFM;

    bits2idxn(avctx, NORM0_BITS, ynrm);

    av_assert0(ynrm[0] >= 0 && ynrm[0] < 40);
    if (FlagN == HUFCODE) {
        hdecnrm(avctx, NB_SFM, &ynrm[1]);
        hcode_l = 0;
        for (int i = 1; i < NB_SFM; i++) {
            av_assert0(ynrm[i] >= 0 && ynrm[i] < 32);
            hcode_l += huffsizn[ynrm[i]];
        }
    } else {
        for (int i = 1; i < NB_SFM; i++) {
            bits2idxn(avctx, NORMI_BITS, &ynrm[i]);
            av_assert0(ynrm[i] >= 0 && ynrm[i] < 40);
        }
        hcode_l = NUMNRMIBITS;
    }

    normqlg2[0] = dicnlg2[ynrm[0]];
    if (is_transient) {
        idxbuf[0] = ynrm[0];
        for (int i = 1; i < NB_SFM; i++)
            idxbuf[i] = ynrm[i] + idxbuf[i-1] - 15;
        recovernorm(idxbuf, ynrm, normqlg2);
        for (int i = 0; i < NB_SFM; i++)
            av_assert0(ynrm[i] >= 0 && ynrm[i] < 40);
    } else {
        for (int i = 1; i < NB_SFM; i++) {
            k = ynrm[i - 1] - 15;
            ynrm[i] += k;
            av_assert0(ynrm[i] >= 0 && ynrm[i] < 40);
            normqlg2[i] = dicnlg2[ynrm[i]];
        }
    }

    for (int i = 0; i < nb_sfm; i++)
        idx[i] = i;

    map_quant_weight(normqlg2, wnorm, is_transient);
    reordvct(wnorm, nb_sfm, idx);
    for (int i = 0; i < NB_SFM; i++)
        R[i] = 0;
    diff = NumSpectumBits - FLAGS_BITS - NORM0_BITS;
    v = diff - hcode_l;
    diff = v;
    bitalloc(wnorm, idx, diff, nb_sfm, QBIT_MAX2, R);

    hcode_l = unpackc(avctx, R, FlagC, 0, 0, SFM_G1, WID_G1, c->ycof);

    k = unpackc(avctx, R, FlagC, NUMC_G1, SFM_G1, SFM_G1G2, WID_G2, c->ycof);
    hcode_l += k;

    k = unpackc(avctx, R, FlagC, NUMC_G1G2, SFM_G1G2, SFM_N, WID_G3, c->ycof);
    hcode_l += k;

    if (nb_sfm > SFM_N) {
        k = unpackc(avctx, R, FlagC, NUMC_N, SFM_N, NB_SFM, WID_GX, c->ycof);
        hcode_l += k;
    }
    diff = v - hcode_l;

    dqcoefs(&c->ycof[0], ynrm, R, 0, SFM_G1, WID_G1, &c->imdct_in[0], &coefsq_norm[0]);
    dqcoefs(&c->ycof[NUMC_G1], ynrm, R, SFM_G1, SFM_G1G2, WID_G2, &c->imdct_in[NUMC_G1], &coefsq_norm[NUMC_G1]);
    dqcoefs(&c->ycof[NUMC_G1G2], ynrm, R, SFM_G1G2, SFM_N, WID_G3, &c->imdct_in[NUMC_G1G2], &coefsq_norm[NUMC_G1G2]);
    dqcoefs(&c->ycof[NUMC_N], ynrm, R, SFM_N, NB_SFM, WID_GX, &c->imdct_in[NUMC_N], &coefsq_norm[NUMC_N]);

    dprocnobitsbfm(avctx, R, idx, ynrm, c->ycof, c->imdct_in, coefsq_norm, nb_sfm, diff);

    return 0;
}

static void fill_spectrum(float *coeff, float *coeff_out, int16_t *R,
                          int16_t is_transient, int16_t norm[], int16_t nf_idx,
                          float *codebook)
{
    int16_t cb_size, cb_pos;
    int16_t last_sfm;
    int16_t first_coeff;
    int16_t low_coeff;
    float *src, *dst, *end;
    float normq;

    cb_size = 0;
    for (int sfm = 0; sfm < NB_SFM; sfm++) {
        if (R[sfm] != 0) {
            for (int j = sfm_start[sfm]; j < sfm_end[sfm]; j++) {
                codebook[cb_size] = coeff[j];
                cb_size++;
            }
        }
    }

    last_sfm = NB_SFM - 1;
    if (is_transient == 0) {
        for (int sfm = NB_SFM - 1; sfm >= 0; sfm--) {
            if (R[sfm] != 0) {
                last_sfm = sfm;
                break;
            }
        }
    }

    if (cb_size != 0) {
        cb_pos = 0;
        for (int sfm = 0; sfm <= last_sfm; sfm++) {
            if (R[sfm] == 0) {
                for (int j = sfm_start[sfm]; j < sfm_end[sfm]; j++) {
                    coeff[j] = codebook[cb_pos];
                    cb_pos++;
                    cb_pos = cb_pos >= cb_size ? 0 : cb_pos;
                }
            }
        }

        if (is_transient == 0) {
            low_coeff = sfm_end[last_sfm] >> 1;
            src       = coeff + sfm_end[last_sfm] - 1;

            first_coeff = sfm_end[last_sfm];
            dst = coeff + sfm_end[last_sfm];
            end = coeff + sfm_end[NB_SFM-1];

            while (dst < end) {
                while (dst < end && src >= &coeff[low_coeff])
                    *dst++ = *src--;
                src++;

                while (dst < end && src < &coeff[first_coeff])
                    *dst++ = *src++;
            }
        }

        for (int sfm = 0; sfm <= last_sfm; sfm++) {
            if (R[sfm] == 0) {
                for (int j = sfm_start[sfm]; j < sfm_end[sfm]; j++)
                    coeff[j] = coeff[j] / powf(2, nf_idx);
            }
        }
    }

    for (int sfm = 0; sfm < NB_SFM; sfm++) {
        normq = dicn[norm[sfm]];
        for (int i = sfm_start[sfm]; i < sfm_end[sfm]; i++)
            coeff_out[i] = coeff[i] * normq;
    }
}

static void de_interleave_spectrum(float *coefs, float *coefs_short)
{
    float *p1a, *p1b, *p2a, *p2b, *p3a, *p3b, *p3c, *p4a, *p4b;
    float *pcoefs, *pcoefs1, *pcoefs2;

    p1a = coefs;
    p1b = coefs + 64;
    p2a = coefs + NUMC_G1;
    p2b = coefs + NUMC_G1 + 64;
    p3a = coefs + NUMC_G23;
    p3b = coefs + NUMC_G23 + 96;
    p3c = coefs + NUMC_G23 + 192;
    p4a = coefs + NUMC_N;
    p4b = coefs + NUMC_N + 128;

    for (int i = 0; i < STOP_BAND; i += STOP_BAND4) {
        pcoefs  = coefs_short + i;
        pcoefs1 = coefs_short + 16 + i;
        for (int j=0; j<16; j++) {
            *pcoefs++  = *p1a++;
            *pcoefs1++ = *p1b++;
        }

        pcoefs  = coefs_short + NUMC_G1SUB + i;
        pcoefs1 = coefs_short + NUMC_G1SUB + 16 + i;
        for (int j = 0; j < 16; j++) {
            *pcoefs++  = *p2a++;
            *pcoefs1++ = *p2b++;
        }

        pcoefs  = coefs_short + NUMC_G1G2SUB + i;
        pcoefs1 = coefs_short + NUMC_G1G2SUB + WID_G3 + i;
        pcoefs2 = coefs_short + NUMC_G1G2SUB + 2 * WID_G3 + i;
        for (int j = 0; j < WID_G3; j++) {
            *pcoefs++  = *p3a++;
            *pcoefs1++ = *p3b++;
            *pcoefs2++ = *p3c++;
        }

        pcoefs  = coefs_short + NUMC_G1G2G3SUB + i;
        pcoefs1 = coefs_short + NUMC_G1G2G3SUB + WID_GX + i;
        for (int j = 0; j < WID_GX; j++) {
            *pcoefs++  = *p4a++;
            *pcoefs1++ = *p4b++;
        }
    }

    /* unpack the spectrum */
    p1a    = coefs_short;
    pcoefs = coefs;
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < STOP_BAND4; j++)
            pcoefs[j] = p1a[j];

        for (int j = STOP_BAND4; j < FRAME_LENGTH / 4; j++)
            pcoefs[j] = 0;
        p1a += STOP_BAND4;
        pcoefs += FRAME_LENGTH / 4;
    }
}

static void inverse_transform(AVCodecContext *avctx, ChannelState *c)
{
    G719Context *s = avctx->priv_data;

    if (c->is_transient) {
        memset(c->imdct_sprev, 0, 240 * sizeof(float));
        for (int seg = 0; seg < NUM_TIME_SWITCHING_BLOCKS; seg++) {
            s->stx_fn(s->stx_ctx, c->imdct_sout,
                      c->imdct_in + seg * 240, sizeof(float));
            s->fdsp->vector_fmul_window(c->imdct_out + seg * 240, c->imdct_sprev + (240 >> 1),
                                        c->imdct_sout, short_window, 240 >> 1);
            memcpy(c->imdct_sprev, c->imdct_sout, 240 * sizeof(float));
        }
    } else {
        s->ltx_fn(s->ltx_ctx, c->imdct_out, c->imdct_in, sizeof(float));
    }
}

static void decode_channel(AVCodecContext *avctx, ChannelState *c, float *samples)
{
    G719Context *s = avctx->priv_data;
    GetBitContext *gb = &s->gb;

    c->is_transient = get_bits1(gb);

    if (c->is_transient) {
        flvqdec(avctx, c, c->audio_q_norm, c->bitalloc, s->num_bits_spectrum_transient, c->ynrm, c->is_transient);
        c->nf_idx = 0;
    } else {
        flvqdec(avctx, c, c->audio_q_norm, c->bitalloc, s->num_bits_spectrum_stationary, c->ynrm, c->is_transient);
        bits2idxn(avctx, 2, &c->nf_idx);
    }

    fill_spectrum(c->audio_q_norm, c->imdct_in, c->bitalloc, c->is_transient, c->ynrm, c->nf_idx, c->codebook);

    if (c->is_transient)
        de_interleave_spectrum(c->imdct_in, c->coefs_short);

    c->old_is_transient = c->is_transient;

    inverse_transform(avctx, c);

    s->fdsp->vector_fmul_window(samples, c->imdct_prev + (960 >> 1),
                                c->imdct_out, window, 960 >> 1);

    memcpy(c->imdct_prev, c->imdct_out, 960 * sizeof(float));
}

static int decode_frame(AVCodecContext *avctx, void *data,
                        int *got_frame_ptr, AVPacket *avpkt)
{
    AVFrame *frame = data;
    G719Context *s = avctx->priv_data;
    GetBitContext *gb = &s->gb;
    float **samples;
    int ret;

    frame->nb_samples = 960;
    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
        return ret;
    samples = (float **)frame->extended_data;

    for (int ch = 0; ch < avctx->channels; ch++) {
        if ((ret = init_get_bits(gb, avpkt->data + (s->num_bits >> 3) * ch,
                                 s->num_bits)) < 0)
            return ret;
        decode_channel(avctx, &s->ch[ch], samples[ch]);
    }

    *got_frame_ptr = 1;

    return avpkt->size;
}

static void decode_flush(AVCodecContext *avctx)
{
    G719Context *s = avctx->priv_data;

    for (int ch = 0; ch < avctx->channels; ch++) {
        ChannelState *c = &s->ch[ch];
        memset(c->imdct_prev, 0, sizeof(c->imdct_prev));
    }
}

static av_cold int decode_close(AVCodecContext *avctx)
{
    G719Context *s = avctx->priv_data;

    av_freep(&s->fdsp);
    av_tx_uninit(&s->ltx_ctx);
    av_tx_uninit(&s->stx_ctx);

    return 0;
}

AVCodec ff_g719_decoder = {
    .name           = "g719",
    .long_name      = NULL_IF_CONFIG_SMALL("G.719"),
    .type           = AVMEDIA_TYPE_AUDIO,
    .id             = AV_CODEC_ID_G719,
    .priv_data_size = sizeof(G719Context),
    .init           = decode_init,
    .decode         = decode_frame,
    .flush          = decode_flush,
    .close          = decode_close,
    .capabilities   = AV_CODEC_CAP_DR1,
    .sample_fmts    = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                      AV_SAMPLE_FMT_NONE },
};
